{"./":{"url":"./","title":"Introduction","keywords":"","body":"Tester Centralize and standardize your tests with easy configuration. Installation dependencies \"react\": \">=16\", \"react-dom\": \">=16\", \"enzyme\": \">=3.8\" npm npm install --save-dev @mighty-justice/tester yarn yarn add --dev @mighty-justice/tester Quick Start Tester lets you configure and bootstrap your tests the way you want to. The possibilities are endless, but here's a quick summary to get you started. In this example, we'll create a Transport hook to mock our API calls, default to a Profile that uses that hook and test it. We will also create a Light profile that allow us to test without the custom hook when needed. Configuration Add this to your jestSetup.js file. // Import the full enzyme to pass it to Tester import enzyme from 'enzyme'; // Import the proper adapter, version 16 is required. import Adapter from 'enzyme-adapter-react-16'; import { TransportMock } from './mocks'; import { ConfigureTester } from '@mighty-justice/tester'; // Adapt enzyme BEFORE configuring Tester enzyme.configure({ adapter: new Adapter() }); // Now you can configure Tester by passing enzyme and the config object TesterConfig.configure(enzyme, { hooks: [ { name: 'Transport', // When the Tester is initialized, run the following onInit: (tester) => { /* You can set whatever you want on the tester, as long as it doesn't conflict with an existing property. */ tester.Transport = new TransportMock(); // You can use any options that you pass on the Tester initialization to run code. if (tester.opts.registerEndpoints) { tester.Transport.register(tester.opts.registerEndpoints); } }, }, ... // You can add as many hooks as you want ], profiles: [ { name: 'Default', // Using Default overwrites the default profile. Transport: true, // These properties MUST match hooks name for them to trigger. }, { name: 'Light', // This creates a Tester.Light Transport: false, // Disable the hook }, ], }); Usage Now that our Tester is configured, let's test one of our components. /* global */ import Button from './button': import { Tester } from '@mighty-justice/tester'; describe('Button', () => { it('Button triggers API call', async () => { const tester = await new Tester( Button, { props: { callsApiOnClick: true } }, ).mount(); expect(tester.Transport.calls.length).toBe(0); tester.component.simulate('click'); expect(tester.Transport.calls.length).toBe(1); }); /* Here, we don't need any Api calls so we use the Light profile which doesn't initialize the Transport. */ it('Button triggers API call', async () => { const tester = await new Tester.Light(Button, { props: { children: 'child string' } }).mount(); expect(tester.text()).toContain('child string'); }); }); Helpers The most helpful helpers are: tester.instance // The instance of the tested component tester.component // The tested component tester.html() // Retrieve mounted component html tester.text() // Retrieve mounted component text tester.wrapper // return of the enzyme mount() // and more... Here's the full list: Helpers Contributing Not availble yet In the wild (Not available yet). Organizations and projects using tester can list themselves here "},"docs/Configuration.html":{"url":"docs/Configuration.html","title":"Configuration","keywords":"","body":"Configuration Add this to your jestSetup.js file. // Import the full enzyme to pass it to Tester import enzyme from 'enzyme'; // Import the proper adapter, version 16 is required. import Adapter from 'enzyme-adapter-react-16'; import { TransportMock } from './mocks'; import { ConfigureTester } from '@mighty-justice/tester'; // Adapt enzyme BEFORE configuring Tester enzyme.configure({ adapter: new Adapter() }); // Now you can configure Tester by passing enzyme and the config object TesterConfig.configure(enzyme, { hooks: [ { name: 'Transport', // When the Tester is initialized, run the following onInit: (tester) => { /* You can set whatever you want on the tester, as long as it doesn't conflict with an existing property. */ tester.Transport = new TransportMock(); // You can use any options that you pass on the Tester initialization to run code. if (tester.opts.registerEndpoints) { tester.Transport.register(tester.opts.registerEndpoints); } }, }, ... // You can add as many hooks as you want ], profiles: [ { name: 'Default', // Using Default overwrites the default profile. Transport: true, // These properties MUST match hooks name for them to trigger. }, { name: 'Light', // This creates a Tester.Light Transport: false, // Disable the hook }, ], }); Pseudo configuration example As you can see in the pseudo-code below, there is no limits to how many Tester Profiles / Hooks you can set. TesterConfig.configure(enzyme, { hooks: [ { name: 'Api', ... }, { name: 'Session', ... }, { name: 'Icons', ... }, { name: 'SelectItemOnInit', ... }, { name: 'ServerNotResponding', ... }, ], profiles: [ { name: 'Default', Api: true, Session: true, }, { name: 'Light', Api: false, Session: false, }, { name: 'Icon', Api: false, Session: false, Icons: true, }, { name: 'SelectItem', Api: true, Session: true, SelectItemOnInit: true, }, { name: 'NoServer', Api: true, Session: true, ServerNotResponding: true, }, ], }); "},"docs/Hooks.html":{"url":"docs/Hooks.html","title":"Hooks","keywords":"","body":"Hooks Hooks are configurable events that allow you to run specific tasks on Tester init and before mounting your components. Hooks are enabled by passing a Profile to a new Tester instance. More about Profiles here. Structure Hooks structure consist of a name and optional options: { name: string, // Name of the hook, used in Profiles to define which is enabled or not. (This is the only required property) component: React.Component, // React Component used to wrap the TestedComponent props: object || fn(tester), // fn() allows you to set more dynamic props. Use an object whenever you can. onInit: fn(tester), // Triggers a function on Tester init (new Tester()). onBeforeMount: fn(tester), // Triggers a function before your component is mounted. (tester.mount()) } Quick example Here is an example of a hook that mock LocalStorage and initialize a user session if passed as an option. // LocalStorage Hook { name: 'localStorage', onInit: (tester) => { window.localStorage = new LocalStorageMock(); if (tester.opts.session) { window.localStorage.bootstrapSession(tester.opts.user || USER); } }, }, // To enable that mock, you need to pass it to Tester either by creating a default Profile or by setting it in the options. // Create Profile { name: 'Storage', LocalStorage: true, // Note: Hooks name get capitalized. } // and trigger with shortcut const tester - new Tester.Storage(TestedComponent); // You can also make set it as default { name: 'Default', LocalStorage: true } const tester - new Tester(TestedComponent); // or, without a Profile, you can pass the hook through the profile option const tester = new Tester(TestedComponent, { profile: { LocalStorage: true } }); Useful examples Not availble yet. "},"docs/Profiles.html":{"url":"docs/Profiles.html","title":"Profiles","keywords":"","body":"Profiles Profiles are presets that defines what which Hooks will be enavled when Tester will be initialized. More about Hooks here. Tester uses the profile named Default when no profile are passed to a new Tester instance. Default is also used to merge custom profile passed to the new Tester instance options. Structure Profiles structure is just a name and Hook names toggling. { name: string, // Name of the profile, used to create Profile Shortcuts (more on that later) HookName: bolean, // Enabled or disabled Hook (that we define when configuring our Tester hooks). ... // The rest is just other Hooks, nothing else } Quick example Here is an example of a profile that would set up a user session based on preivously created Api and Session hooks. // Profile { name: 'User', Api: true, Session: true, } Shortcuts Any profile has it's own shortcut using the Profile's name. In the example above, the shortcut would be called: Tester.User() By default, we have the Tester.Default() profile available, which is equal to doing Tester(). Overwrite default You can easily overwrite the Default shortcut by simply passing it as a name: // Overwrite Default profile { name: 'Default', Api: true, Session: false, } Tester() and Tester.Default() will now use this profile: { Api: true, Session: false }. "},"docs/Usage.html":{"url":"docs/Usage.html","title":"Usage","keywords":"","body":"Usage One your Tester is configured, there is a couple of ways you can use it. Multi steps // The Tester instance is created, onInit is called, but the TestedComponent is not mounted yet. const tester = new Tester(TestedComponent, { props: { color: 'blue' } }); // We're now mounting the componnent. tester.mount(); // the component is ready and we can use all the uitls available. tester.instance(); tester.html(); tester.text(); ... Awaiting for API calls to finish after mount /* If we trigger a lot of API calls and event when mounting our TestedComponent, we can use the 'async' options when mounting it. */ const tester = new Tester(TestedComponent, { props: { color: 'blue' } }); // This will automatically run tester.sleep(); + tester.update(); right after mounting the TestedComponent. await tester.mount({ async: true }); // The 'async' option is a shortut for this: const tester = new Tester(TestedComponent, { props: { color: 'blue' } }); tester.mount(); await tester.sleep(); await tester.update(); All the shortcuts ! const tester = await new Tester(TestedComponent, { props: { color: 'blue' } }).mount({ async: true }); // Your TestedComponent is now mounted, it did wait for API calls to finish and updated once. // You can now use all the utils available. "},"docs/Helpers.html":{"url":"docs/Helpers.html","title":"Helpers","keywords":"","body":"Helpers Basic Basic helpers that returns what has been mounted OR are simply enzyme shortcuts. tester.instance // The instance of the tested component tester.component // The tested component tester.html() // Retrieve mounted component html tester.text() // Retrieve mounted component text tester.wrapper // return of the enzyme mount() tester.update(); // shortcut for enzyme update(); sleep /* await 20ms, useful when triggering mocked Api Calls */ tester.sleep(); refresh /* Calls both tester.sleep() and tester.refresh() to allow waiting for an action to be fully complete. e.g click + api call + render update. */ tester.refresh(); debug // render tester.wrapper.debug(); in a console log tester.debug(); "}}