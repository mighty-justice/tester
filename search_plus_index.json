{"./":{"url":"./","title":"Introduction","keywords":"","body":"Tester Centralize and standardize your tests with easy configuration. Installation dependencies \"react\": \">=16\", \"react-dom\": \">=16\", \"enzyme\": \">=3.8\" npm npm install --save-dev @mighty-justice/tester yarn yarn add --dev @mighty-justice/tester Quick Start Tester lets you configure and bootstrap your tests the way you want to. The possibilities are endless, but here's a quick summary to get you started. In this example, we'll create a Transport hook to mock our API calls and test it. Configuration Add this to your jestSetup.js file. // Import the full enzyme to pass it to Tester import enzyme from 'enzyme'; // Import the proper adapter, version 16 is required. import Adapter from 'enzyme-adapter-react-16'; import { TransportMock } from './mocks'; import { ConfigureTester } from '@mighty-justice/tester'; // Adapt enzyme BEFORE configuring Tester enzyme.configure({ adapter: new Adapter() }); // Now you can configure Tester by passing enzyme and the config object TesterConfig.configure(enzyme, { hooks: [ { name: 'Transport', // When the Tester is initialized, run the following onInit: (tester) => { /* You can set whatever you want on the tester, as long as it doesn't conflict with an existing property. */ tester.Transport = new TransportMock(); // You can use any options that you pass on the Tester initialization to run code. if (tester.opts.registerEndpoints) { tester.Transport.register(tester.opts.registerEndpoints); } }, }, // ... // You can add as many hooks as you want ], }); Usage Now that our Tester is configured, let's test one of our components. /* global */ import Button from './button': import { Tester } from '@mighty-justice/tester'; describe('Button', () => { it('Button triggers API call', async () => { const tester = await new Tester( Button, { props: { callsApiOnClick: true } }, ).mount(); expect(tester.Transport.calls.length).toBe(0); tester.component.simulate('click'); expect(tester.Transport.calls.length).toBe(1); }); }); Helpers The most helpful helpers are: tester.instance // The instance of the tested component tester.component // The tested component tester.html() // Retrieve mounted component html tester.text() // Retrieve mounted component text tester.wrapper // return of the enzyme mount() // and more... Here's the full list: Helpers Contributing Not availble yet In the wild (Not available yet). Organizations and projects using tester can list themselves here "},"docs/Configuration.html":{"url":"docs/Configuration.html","title":"Configuration","keywords":"","body":"Configuration Add this to your jestSetup.js file. // Import the full enzyme to pass it to Tester import enzyme from 'enzyme'; // Import the proper adapter, version 16 is required. import Adapter from 'enzyme-adapter-react-16'; import { TransportMock } from './mocks'; import { ConfigureTester } from '@mighty-justice/tester'; // Adapt enzyme BEFORE configuring Tester enzyme.configure({ adapter: new Adapter() }); // Now you can configure Tester by passing enzyme and the config object TesterConfig.configure(enzyme, { hooks: [ { name: 'Transport', // When the Tester is initialized, run the following onInit: (tester) => { /* You can set whatever you want on the tester, as long as it doesn't conflict with an existing property. */ tester.Transport = new TransportMock(); // You can use any options that you pass on the Tester initialization to run code. if (tester.opts.registerEndpoints) { tester.Transport.register(tester.opts.registerEndpoints); } }, }, // ... // You can add as many hooks as you want ], }); Pseudo configuration example As you can see in the pseudo-code below, there is no limits to how many Tester Hooks you can set. TesterConfig.configure(enzyme, { hooks: [ { name: 'Api', ... }, { name: 'Session', ... }, { name: 'Icons', ... }, { name: 'SelectItemOnInit', ... }, { name: 'ServerNotResponding', ... }, ], }); "},"docs/Hooks.html":{"url":"docs/Hooks.html","title":"Hooks","keywords":"","body":"Hooks Hooks are configurable events that allow you to run specific tasks on Tester init and before mounting your components. Structure A hook's structure consists of a required name and optional options: { name: string, // Name of the hook (This is the only required property) component: React.Component, // React Component used to wrap the TestedComponent props: object || fn(tester), // fn() allows you to set more dynamic props. Use an object whenever you can. onInit: fn(tester), // Triggers a function on Tester init (new Tester()). onBeforeMount: fn(tester), // Triggers a function before your component is mounted. (tester.mount()) } Quick example Here is an example of a hook that mocks LocalStorage and initializes a user session if passed as an option. // LocalStorage Hook { name: 'localStorage', onInit: (tester) => { window.localStorage = new LocalStorageMock(); if (tester.opts.session) { window.localStorage.bootstrapSession(tester.opts.user || USER); } }, }, // To enable that mock, you need to pass it to Tester by setting it in the options. // You can also make set it as default { name: 'Default', LocalStorage: true } const tester = new Tester(TestedComponent); Useful examples Not available yet. "},"docs/Usage.html":{"url":"docs/Usage.html","title":"Usage","keywords":"","body":"Usage Once your Tester is configured, there are a couple of ways you can use it. Multi steps // The Tester instance is created, onInit is called, but the TestedComponent is not mounted yet. const tester = new Tester(TestedComponent, { props: { color: 'blue' } }); // We're now mounting the component. tester.mount(); // the component is ready and we can use all the utils available. tester.instance(); tester.html(); tester.text(); ... Awaiting API calls to finish after mount /* If we trigger a lot of API calls and event when mounting our TestedComponent, we can use the 'async' options when mounting it. */ const tester = new Tester(TestedComponent, { props: { color: 'blue' } }); // This will automatically run tester.sleep(); and tester.update(); // right after mounting the TestedComponent. await tester.mount({ async: true }); // The 'async' option is a shortut for this: const tester = new Tester(TestedComponent, { props: { color: 'blue' } }); tester.mount(); await tester.sleep(); await tester.update(); All the shortcuts ! const tester = await new Tester(TestedComponent, { props: { color: 'blue' } }).mount({ async: true }); // Your TestedComponent is now mounted. It waited for API calls to finish and updated once. // You can now use all the utils available. "},"docs/Helpers.html":{"url":"docs/Helpers.html","title":"Helpers","keywords":"","body":"Helpers Basic Basic helpers that return what has been mounted OR are simply enzyme shortcuts. tester.instance // The instance of the tested component tester.component // The tested component tester.html() // Retrieve mounted component html tester.text() // Retrieve mounted component text tester.wrapper // return of the enzyme mount() tester.update(); // shortcut for enzyme update(); sleep /* await 20ms, useful when triggering mocked Api Calls */ tester.sleep(); refresh /* Calls both tester.sleep() and tester.update() to wait for an action to be fully complete. e.g. click + api call + render update. */ tester.refresh(); debug // render tester.wrapper.debug(); in a console log tester.debug(); "}}